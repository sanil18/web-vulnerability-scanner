import requests
from bs4 import BeautifulSoup
import re
from packaging import version
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
import tldextract
import whois
import datetime

class WebVulnerabilityScanner:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        self.vulnerabilities = []

    def scan_sql_injection(self):
        print("Scanning for SQL Injection vulnerabilities...")
        response = self.session.get(self.target_url)

        if response.status_code == 200:
            soup = BeautifulSoup(response.text, 'html.parser')
            sql_patterns = ["sql", "select", "from", "where", "union", "1=1"]

            for pattern in sql_patterns:
                if re.search(fr'\b{re.escape(pattern)}\b', soup.text, re.IGNORECASE):
                    print(f"Potential SQL Injection found: {pattern}")
                    self.vulnerabilities.append({'type': 'SQL Injection', 'details': f"Potential SQL Injection found: {pattern}"})

            print("SQL Injection scan completed.")
        else:
            print(f"Failed to fetch the URL. Status code: {response.status_code}")

    def scan_xss(self):
        print("Scanning for Cross-Site Scripting (XSS) vulnerabilities...")
        response = self.session.get(self.target_url)

        if response.status_code == 200:
            soup = BeautifulSoup(response.text, 'html.parser')

            scripts = soup.find_all('script')
            for script in scripts:
                if re.search(r'(<\s*script[^>]*>.*<\s*/\s*script\s*>)', str(script), re.IGNORECASE):
                    print("Potential XSS vulnerability found.")
                    self.vulnerabilities.append({'type': 'XSS', 'details': 'Potential XSS vulnerability found.'})
                    break

            print("XSS scan completed.")
        else:
            print(f"Failed to fetch the URL. Status code: {response.status_code}")

    def scan_outdated_software(self):
        print("Scanning for outdated software versions...")
        try:
            headers = {'User-Agent': 'WebVulnerabilityScanner'}
            response = requests.get(self.target_url, headers=headers)

            server_header = response.headers.get('Server')
            if server_header:
                software_version = extract_version_from_header(server_header)
                if is_outdated(software_version, "1.0.0"):
                    print(f"Outdated software version detected: {software_version}")
                    self.vulnerabilities.append({'type': 'Outdated Software', 'details': f"Outdated software version detected: {software_version}"})
                else:
                    print("Software is up to date.")
            else:
                print("Version information not available in HTTP headers.")
        except requests.exceptions.RequestException as e:
            print(f"Error checking software version: {e}")

    def machine_learning_classifier(self, url):
        print("Fetching real-time phishing data from PhishTank API...")
        phishtank_api_url = 'https://www.phishtank.com/developer_info.php'
        try:
            response = requests.get(phishtank_api_url)
            response.raise_for_status()

            if response.text.strip():
                phishing_data = response.json()
                vectorizer = TfidfVectorizer()

                urls = [entry['url'] for entry in phishing_data]
                labels = [entry['valid'] for entry in phishing_data]

                X = vectorizer.fit_transform(urls)
                X_train, X_test, y_train, y_test = train_test_split(X, labels, test_size=0.2, random_state=42)

                classifier = RandomForestClassifier(n_estimators=100, random_state=42)
                classifier.fit(X_train, y_train)

                prediction = classifier.predict(vectorizer.transform([url]))
                print(f"Phishing Prediction: {'Non-Phishing' if prediction[0] else 'Phishing'}")
                self.vulnerabilities.append({'type': 'Phishing', 'details': f"Phishing Prediction: {'Non-Phishing' if prediction[0] else 'Phishing'}"})
            else:
                print("Phishing data not available in the response.")
        except requests.exceptions.RequestException as e:
            print(f"Error fetching phishing data from PhishTank API: {e}")

    def check_domain_age(self, url):
        extract_result = tldextract.extract(url)
        domain = extract_result.domain + '.' + extract_result.suffix

        try:
            domain_info = whois.whois(domain)
            creation_date = domain_info.creation_date
            if isinstance(creation_date, list):
                creation_date = creation_date[0]

            current_date = datetime.datetime.now()
            domain_age = (current_date - creation_date).days
            print(f"Domain Age: {domain_age} days")
            self.vulnerabilities.append({'type': 'Domain Age', 'details': f"Domain Age: {domain_age} days"})
        except Exception as e:
            print(f"Error retrieving domain information: {e}")

    def run_scan(self):
        print(f"Starting vulnerability scan for {self.target_url}")
        self.scan_sql_injection()
        self.scan_xss()
        self.scan_outdated_software()
        self.machine_learning_classifier(self.target_url)
        self.check_domain_age(self.target_url)

        if self.vulnerabilities:
            print("\nVulnerability Report:")
            for idx, vulnerability in enumerate(self.vulnerabilities, start=1):
                print(f"{idx}. Type: {vulnerability['type']}\n   Details: {vulnerability['details']}")

        print("\nVulnerability scan completed.")


def extract_version_from_header(header):
    match = re.search(r'\b\d+\.\d+\.\d+\b', header)
    if match:
        return match.group()
    else:
        return None

def is_outdated(current_version, threshold_version):
    return version.parse(current_version) < version.parse(threshold_version)


target_url = "http://www.example.com"
scanner = WebVulnerabilityScanner(target_url)
scanner.run_scan()
